| \b\*Scala Workshop - session 5

1) Organisatorisches
2) Fragen vom letzten mal
3) Discuss "homework" (section4)
4) Futures
5) Promises
6) For-Comprehensions
7) Homework for next time
8) Feedback

---
| \b\* Organisatorisches

Urlaub :-)
19.05. - 12.06.

Vielleicht zur Überbrückung:

Es gibt ein ganz brauchbares kostenloses E-Book zum Scala lernen: http://fileadmin.cs.lth.se/scala/scala-impatient.pdf
Da sind bei jedem Kapitel Übungen drinnen Lösungen findet man ggf. im Netz.

+ Themenwünsche sammeln!

---
| \b\* Fragen vom letzten mal - === und Pattern matching mit Listen

=== kommt aus dem Trait org.scalautils.TripleEqualsSupport - aus Scalatest

http://www.scalatest.org/getting_started_with_fun_suite

" Using triple equals [will] give you the more informative error message, "1 did not equal 2": "

--
/

Pattern matching mit Listen:

```
val numbers = List (2, 4, 6, 8)

def sum(list: List[Int]): Int = {
  list match {
    case x :: xs => x + sum(xs)
    case Nil => 0
  }
}

```

---
| \b\* Fragen vom letzten mal - pattern macthing & type erasure

Problem:

```
val list = List(1,2,3)

list match {
  case x: List[String] => println("List of Strings")
  case x: List[Int] => println("List of Ints")
}

```

--

Possible Solution:

```
import reflect.runtime.universe._

def matchList[A: TypeTag](c: List[A]) = c match {
  case c: List[String] if typeOf[A] <:< typeOf[String] => println("List of Strings")
  case c: List[Int] if typeOf[A] <:< typeOf[Int] => println("List of Ints")
  case c: List[_] => println("other")
}

matchList(list)
```

--

or see http://stackoverflow.com/questions/35181533/can-we-elegantly-match-an-erased-type-in-scala/35181934#35181934

--

or better leave it ;-)

---
| \b\* Fragen vom letzen mal - Diamond Problem


```
trait Base {
   def op: String = "base"
}

trait Foo extends Base {
   override def op = "foo"
}

trait Bar extends Base {
   override def op = "bar"
}

class Diamond extends Foo with Bar {

  def foo(): String = super[Foo].op

  def bar(): String = op

  // geht nicht!
  //def base(): String = super[Base].op
}

val d = new Diamond()
```

--

Kein Problem mit Konstruktor-Aufrufen: Traits haben keine Konstruktoren :-)

Auswahl der Methode erfolg "von rechts nach links"

```
d.op
```

--

Weitere Methoden lassen sich explizit ansprechen:

```
d.foo
d.bar

```


---
| \b\* Futures

Scala bietet eine Future Klasse die es erlaubt Aufgaben (z.B. Netzwerk oder Dateizugriffe)
asynchron auszuführen. Vergleichbar mit einem Future bzw. FutureTask in Java.

```
val future = Future {
    someBlockingCall()
}
```

--

Dieser Aufruf führt bereits dazu dass das Future einem ExecutionContext zur
Ausführung übergeben wird.

Methodensignatur der apply Methode im Future Companion Objekt:

```
def apply[T](body: =>T)(implicit execctx: ExecutionContext): Future[T]
```

---

Der ExecutionContext kann entweder direkt als Parameter übergeben oder implizit eingebunden
werden. Um die Verwendung von Futures einfacher zu machen, bietet Scala einen globalen
ExecutionContext der automatisch durch einen import verwendet werden kann:

```
import scala.concurrent.ExecutionContext.Implicits.global

val future = Future {
    someBlockingCall()
}
```

Syntactic sugar für

```
val future = Future.apply({
    "hello future"
})(scala.concurrent.ExecutionContext.Implicits.global)
```

---
| \b\* Beispiel 1

```
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global

val f1 = Future {
    Thread.sleep(5000)
    "Future 1 completed"
}
val f2 = Future {
    Thread.sleep(2000)
    "Future 2 completed"
}

f1 onSuccess { case str => println(str) }
f2 onSuccess { case str => println(str) }
```

---
| \b\* Beispiel 2

```
import java.lang.RuntimeException
import scala.util.{Try, Success, Failure}
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global

val f = Future {
    Thread.sleep(2000)
    throw new RuntimeException("Future 1 failed")
}

f onComplete {
  case Success(str) => println(s"onComplete: $str")
  case Failure(t) => println("An error has occured: " + t.getMessage)
}
```

---
| \b\* Verwendung?

Zum Beispiel im Play Framework bei der Verwendung des WSClient um
einen HTTP Aufruf zu tätigen:

```
def scrapeShop() = Action.async {
    ws.url("https://shop.rewe.de/").get()
        .map(result => processResult(result))
}
```

---
| \b\* Promises

Ein Promise separiert die ausgeführte Berechnung von dem Future. So ist es möglich an einer
beliebigen Stelle im Code bzw. in irgendeinem Thread ein Future zu vervollständigen. Ein Promise
kann dazu genau einmal zugewiesen werden.

```
import scala.concurrent.{Future, Promise}
import scala.concurrent.ExecutionContext.Implicits.global

val promise = Promise[String]()
val future = promise.future

future onSuccess { case r => println("Promise has been kept: " + r) }

val producer = Future {
  val result = "hi there :)"
  Thread.sleep(2000)
  promise.success(result)
  // Do further stuff
}
```

---
| \b\* For-Comprehensions
TODO
